// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.0
// LVGL version: 8.3.11
// Project name: anemometre

#include "LVGL_UI/ui.h"
#include "../components/lvgl__lvgl/lvgl.h"
#include "QMI8658.h"
#include <stdio.h> //for basic printf commands
#include "LVGL_UI/ui.h"
#include "QMI8658.h"
#include <stdlib.h>
#include <string.h>
#include "esp_log.h"
#include "esp_http_client.h"
#include "nvs_flash.h"
#include "cJSON/cJSON.h"
#include "SD_MMC.h"
#include <dirent.h>
#include <stdbool.h>

#define HTTP_RESPONSE_SIZE 512
#define BUFFER_SIZE 1024 //2048 // was 1024

static const char *TAG;

SemaphoreHandle_t http_mutex = NULL;
static const char *TAG = "HTTP_CLIENT";
static char temperature_str[128] = "N/A";
static char pression_str[128] = "N/A";
void http_simple_get(const char *host, const char *path, uint16_t port);
float temperature_actuelle = 0.0f;
float temperature_max = -100.0f;
float temperature_min = 100.0f;
static char temperature_max_str[128] = "N/A";
static char temperature_min_str[128] = "N/A";

//////////// gite /////////////
#include <math.h>
float gite = 0.0f;
static float filtered_accel_y = 0.0f;
const float alpha = 0.1f; // 0 < alpha < 1 (plus petit = plus amorti)
//////////////////////////////

/////////// pression /////////////
float pression_actuelle = 0.0f;
static int compteur_pression = 0;
//////////////////////////////////

//////////// SD ////////////////
int numero_ligne = 0;
////////////////////////////////

////////// VENT ///////////////
float vent_vitesse = 0.1f;
float direction_int = 0.0f;
float vent_rafale = 0.1f;
float vent_rafale_jour = 0.0f;
///////////////////////////////

//////////// BATT ///////
int battery_level_old = 0;
/////////////////////////

/////////// GRAPHE ///////
extern lv_chart_series_t *baro_series;
extern lv_coord_t baro_values[];
extern int baro_index;
extern lv_obj_t *ui_graphe;
///////////////////////////

static void set_value_g(void *ui_Arc1, int32_t gite_acc)
 {
    gite_acc = 30*(double)Accel.y;
    float current_accel_y = gite_acc;
    filtered_accel_y = alpha * current_accel_y + (1 - alpha) * filtered_accel_y;
    float Accel_y = (float)filtered_accel_y / 30.0f; // pr√©cision
    int gite = (int)(Accel_y * 63.0f + 50.0f);
    if (gite > 100) gite = 100;
    else if (gite < 0) gite = 0;
    vTaskDelay(pdMS_TO_TICKS(10));
    lv_arc_set_value(ui_Arc1, gite);
}

void ui_modetemp_screen_init(void)
{
    ui_modetemp = lv_obj_create(NULL);
    lv_obj_clear_flag(ui_modetemp, LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC |
                      LV_OBJ_FLAG_SCROLL_MOMENTUM);     /// Flags
    lv_obj_set_scrollbar_mode(ui_modetemp, LV_SCROLLBAR_MODE_ON);
    ui_object_set_themeable_style_property(ui_modetemp, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_BG_COLOR,
                                           _ui_theme_color_fond);
    ui_object_set_themeable_style_property(ui_modetemp, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_BG_OPA,
                                           _ui_theme_alpha_fond);

    ui_Label2 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label2, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Label2, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Label2, 0);
    lv_obj_set_y(ui_Label2, -100);
    lv_obj_set_align(ui_Label2, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label2, "Temperature Exterieure");
    ui_object_set_themeable_style_property(ui_Label2, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label2, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);
    lv_obj_set_style_text_font(ui_Label2, &lv_font_montserrat_24, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_Label1 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label1, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Label1, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Label1, -45);
    lv_obj_set_y(ui_Label1, 28);
    lv_obj_set_align(ui_Label1, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label1, "N/A");
    ui_object_set_themeable_style_property(ui_Label1, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label1, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);
    lv_obj_set_style_text_font(ui_Label1, &ui_font_Arial, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_Label6 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label6, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Label6, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Label6, 120);
    lv_obj_set_y(ui_Label6, -25);
    lv_obj_set_align(ui_Label6, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label6, "¬∞C");
    ui_object_set_themeable_style_property(ui_Label6, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label6, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);
    lv_obj_set_style_text_font(ui_Label6, &lv_font_montserrat_40, LV_PART_MAIN | LV_STATE_DEFAULT);

    ////////////// TEMP MIN MAX /////////////////////////////
    ui_Label25 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label25, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Label25, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Label25, 170);
    lv_obj_set_y(ui_Label25, 61);
    lv_obj_set_align(ui_Label25, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label25, "Min: N/A");
    ui_object_set_themeable_style_property(ui_Label25, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label25, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);
    lv_obj_set_style_text_font(ui_Label25, &lv_font_montserrat_16, LV_PART_MAIN | LV_STATE_DEFAULT);

    ui_Label26 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label26, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Label26, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Label26, 170);
    lv_obj_set_y(ui_Label26, 26);
    lv_obj_set_align(ui_Label26, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label26, "Max: N/A");
    ui_object_set_themeable_style_property(ui_Label26, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label26, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);
    lv_obj_set_style_text_font(ui_Label26, &lv_font_montserrat_16, LV_PART_MAIN | LV_STATE_DEFAULT);

    //////////////// ECHELLE 0 /////////////////
    ui_Label0 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label0, 7);
    lv_obj_set_height(ui_Label0, 18);
    lv_obj_set_x(ui_Label0, 1);
    lv_obj_set_y(ui_Label0, 192);
    lv_obj_set_align(ui_Label0, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label0, "|");
    lv_obj_clear_flag(ui_Label0, LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE | LV_OBJ_FLAG_GESTURE_BUBBLE |
                      LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM |
                      LV_OBJ_FLAG_SCROLL_CHAIN);     /// Flags
    ui_object_set_themeable_style_property(ui_Label0, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label0, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);
    lv_obj_set_style_text_align(ui_Label0, LV_TEXT_ALIGN_CENTER, LV_PART_MAIN | LV_STATE_DEFAULT);

    /////////////  INCLINOMETRE  ////////////////////
    ui_Arc1 = lv_arc_create(ui_modetemp);
    lv_obj_set_width(ui_Arc1, 430);
    lv_obj_set_height(ui_Arc1, 430);
    lv_obj_set_align(ui_Arc1, LV_ALIGN_CENTER);
    lv_obj_clear_flag(ui_Arc1, LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_PRESS_LOCK | LV_OBJ_FLAG_CLICK_FOCUSABLE |
                      LV_OBJ_FLAG_SNAPPABLE | LV_OBJ_FLAG_SCROLLABLE | LV_OBJ_FLAG_SCROLL_ELASTIC | LV_OBJ_FLAG_SCROLL_MOMENTUM |
                      LV_OBJ_FLAG_SCROLL_CHAIN);     /// Flags
    lv_obj_set_scrollbar_mode(ui_Arc1, LV_SCROLLBAR_MODE_OFF);
    lv_obj_set_style_arc_color(ui_Arc1, lv_color_hex(0x4040FF), LV_PART_INDICATOR | LV_STATE_DEFAULT);
    lv_obj_set_style_arc_opa(ui_Arc1, 0, LV_PART_INDICATOR | LV_STATE_DEFAULT);
    lv_arc_set_range(ui_Arc1, 0, 100);
    lv_arc_set_bg_angles(ui_Arc1, 0, 100);
    lv_arc_set_mode(ui_Arc1, LV_ARC_MODE_NORMAL);
    lv_arc_set_rotation(ui_Arc1, 40);
    lv_obj_set_style_arc_width(ui_Arc1, 10, LV_PART_MAIN | LV_STATE_DEFAULT);

    lv_obj_set_style_border_color(ui_Arc1, lv_color_hex(0x949494), LV_PART_KNOB | LV_STATE_DEFAULT);
    lv_obj_set_style_border_opa(ui_Arc1, 255, LV_PART_KNOB | LV_STATE_DEFAULT);
    lv_obj_set_style_blend_mode(ui_Arc1, LV_BLEND_MODE_NORMAL, LV_PART_KNOB | LV_STATE_DEFAULT);

    lv_obj_set_style_pad_left(ui_Arc1, 10, LV_PART_KNOB | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_right(ui_Arc1, 10, LV_PART_KNOB | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_top(ui_Arc1, 10, LV_PART_KNOB | LV_STATE_DEFAULT);
    lv_obj_set_style_pad_bottom(ui_Arc1, 10, LV_PART_KNOB | LV_STATE_DEFAULT);

    uic_modetemp = ui_modetemp;

    // Animation pour la valeur de la bille //
    lv_anim_t anim;
    lv_anim_init(&anim);
    lv_anim_set_exec_cb(&anim, set_value_g); // Callback pour mettre √† jour la valeur de la bille
    lv_anim_set_var(&anim, ui_Arc1); // L'indicateur √† animer
    lv_anim_set_values(&anim, -70, 70);  // Plage de l'animation
    lv_anim_set_time(&anim, 500);  // Dur√©e de l'animation
    lv_anim_set_repeat_delay(&anim, 0);  /*D√©lai avant la r√©p√©tition. La valeur par d√©faut est 0 (d√©sactiv√©) [ms]*/
    lv_anim_set_playback_time(&anim, 0);  /*Lorsque l'animation est pr√™te, elle est jou√©e √† l'envers avec cette dur√©e. La valeur par d√©faut est 0 (d√©sactiv√©) [ms]*/
    lv_anim_set_path_cb(&anim, lv_anim_path_ease_in_out); 
    lv_anim_set_repeat_count(&anim, LV_ANIM_REPEAT_INFINITE);
    lv_anim_start(&anim);

    /////// ECHELLE ////////////

    ui_Labelinclino = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Labelinclino, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Labelinclino, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Labelinclino, 0);
    lv_obj_set_y(ui_Labelinclino, 126);
    lv_obj_set_align(ui_Labelinclino, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Labelinclino, "Inclinometre");
    ui_object_set_themeable_style_property(ui_Labelinclino, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Labelinclino, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);

    ui_Label7 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label7, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Label7, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Label7, 77);
    lv_obj_set_y(ui_Label7, 154);
    lv_obj_set_align(ui_Label7, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label7, "30");
    ui_object_set_themeable_style_property(ui_Label7, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label7, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);

    ui_Label8 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label8, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Label8, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Label8, 0);
    lv_obj_set_y(ui_Label8, 175);
    lv_obj_set_align(ui_Label8, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label8, "0");
    ui_object_set_themeable_style_property(ui_Label8, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label8, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);

    ui_Label9 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label9, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Label9, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Label9, -77);
    lv_obj_set_y(ui_Label9, 154);
    lv_obj_set_align(ui_Label9, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label9, "30");
    ui_object_set_themeable_style_property(ui_Label9, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label9, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);

    ui_Label10 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label10, LV_SIZE_CONTENT);   /// 1
    lv_obj_set_height(ui_Label10, LV_SIZE_CONTENT);    /// 1
    lv_obj_set_x(ui_Label10, -112);
    lv_obj_set_y(ui_Label10, 130);
    lv_obj_set_align(ui_Label10, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label10, "45");
    ui_object_set_themeable_style_property(ui_Label10, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label10, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);

    ui_Label11 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label11, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_Label11, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_Label11, 109);
    lv_obj_set_y(ui_Label11, 133);
    lv_obj_set_align(ui_Label11, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label11, "45");
    ui_object_set_themeable_style_property(ui_Label11, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label11, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);

    ui_Label13 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label13, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_Label13, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_Label13, 39);
    lv_obj_set_y(ui_Label13, 167);
    lv_obj_set_align(ui_Label13, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label13, "15");
    ui_object_set_themeable_style_property(ui_Label13, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label13, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);

    ui_Label21 = lv_label_create(ui_modetemp);
    lv_obj_set_width(ui_Label21, LV_SIZE_CONTENT);
    lv_obj_set_height(ui_Label21, LV_SIZE_CONTENT);
    lv_obj_set_x(ui_Label21, -39);
    lv_obj_set_y(ui_Label21, 167);
    lv_obj_set_align(ui_Label21, LV_ALIGN_CENTER);
    lv_label_set_text_fmt(ui_Label21, "15");
    ui_object_set_themeable_style_property(ui_Label21, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_COLOR,
                                           _ui_theme_color_texte);
    ui_object_set_themeable_style_property(ui_Label21, LV_PART_MAIN | LV_STATE_DEFAULT, LV_STYLE_TEXT_OPA,
                                           _ui_theme_alpha_texte);
    lv_obj_add_event_cb(ui_modetemp, ui_event_modetemp, LV_EVENT_ALL, NULL);
    uic_modetemp = ui_modetemp;


    ///////////  INIT  HTML  /////////////
    vTaskDelay(pdMS_TO_TICKS(10000));  // Attendre que la connexion WiFi soit √©tablie
    
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }

    DIR* dir = opendir("/sdcard");
        if (dir != NULL) {
    ESP_LOGI(TAG, "‚úÖ Carte SD accessible !");
    closedir(dir);
        } else {
    ESP_LOGE(TAG, "‚ùå Erreur ouverture carte SD !");
        }

    ESP_ERROR_CHECK(ret);
    ESP_LOGI(TAG, "M√©moire libre : %lu bytes", esp_get_free_heap_size());
    ESP_LOGI(TAG, "M√©moire max allocable : %d bytes", heap_caps_get_largest_free_block(MALLOC_CAP_8BIT));
    const char *host = "192.168.2.237";
    const char *path = "/get_livedata_info?";
    uint16_t port = 80;
    http_simple_get(host, path, port);  // R√©cup√®re la page et extrait les donn√©es
}

void http_simple_get(const char *host, const char *path, uint16_t port) {
    char request[1024];
    //char recv_buf[BUFFER_SIZE];
    char *recv_buf = malloc(BUFFER_SIZE);
    if (!recv_buf) {
        ESP_LOGE(TAG, "‚ùå √âchec allocation m√©moire !");
        xSemaphoreGive(http_mutex);
        return;
    }
    struct sockaddr_in dest_addr;
    int sock, err;

    if (http_mutex == NULL) {
        ESP_LOGE(TAG, "‚ùå Mutex HTTP non initialis√© !");
        return;
    }
    else if (compteur_pression == 1)
        ESP_LOGI(TAG, "üîí Mutex acquis. D√©but requ√™tes HTTP...");

    if (xSemaphoreTake(http_mutex, pdMS_TO_TICKS(500)) != pdTRUE) {
        ESP_LOGE(TAG, "‚ùå Mutex indisponible !");
        return;
    }
    
    dest_addr.sin_addr.s_addr = inet_addr(host);
    dest_addr.sin_family = AF_INET;
    dest_addr.sin_port = htons(port);

    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    if (sock < 0) {
        ESP_LOGE(TAG, "‚ùå Impossible de cr√©er le socket !");
        lv_label_set_text_fmt(ui_Label1, "N/A");
        lv_obj_invalidate(ui_Label1);
        lv_label_set_text_fmt(ui_Label22, "N/A");
        lv_obj_invalidate(ui_Label22);
        xSemaphoreGive(http_mutex);
        return;
    }

    err = connect(sock, (struct sockaddr *)&dest_addr, sizeof(dest_addr));
    if (err != 0) {
        ESP_LOGE(TAG, "‚ùå √âchec connexion socket : errno %d", errno);
        lv_label_set_text_fmt(ui_Label1, "N/A");
        lv_obj_invalidate(ui_Label1);
        lv_label_set_text_fmt(ui_Label22, "N/A");
        lv_obj_invalidate(ui_Label22);
        close(sock);
        xSemaphoreGive(http_mutex);
        return;
    }

    struct timeval timeout;
    timeout.tv_sec = 2;      // Timeout de 2 secondes
    timeout.tv_usec = 300000;

    setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof timeout);
    setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof timeout);

    snprintf(request, sizeof(request),
             "GET %s HTTP/1.0\r\n"
             "Host: %s\r\n"
             "User-Agent: ESP32\r\n\r\n",
             path, host);

    err = send(sock, request, strlen(request), 0);
    if (err < 0) {
        ESP_LOGE(TAG, "‚ùå Erreur envoi requ√™te !");
        close(sock);
        xSemaphoreGive(http_mutex);
        return;
    }

    //ESP_LOGI(TAG, "Requ√™te envoy√©e, attente r√©ponse...");

    int total_read = 0, len;
    do {
        len = recv(sock, recv_buf + total_read, BUFFER_SIZE - total_read - 1, 0);
        if (len > 0) {
            total_read += len;
        }
    } while (len > 0 && total_read < BUFFER_SIZE - 1);

    if (total_read > 0) {
        recv_buf[total_read] = '\0';
        char *json_start = strstr(recv_buf, "\r\n\r\n");
        if (json_start) {
            json_start += 4;  // Saute les headers HTTP
            //ESP_LOGI(TAG, "üõ¨ Total re√ßu : %d octets", total_read);
            //ESP_LOGI(TAG, "Contenu JSON brut : %s", json_start);
            parse_json_data(json_start);
        } else {
            ESP_LOGE(TAG, "‚ùå R√©ponse HTTP invalide !");
        }
    } else {
        ESP_LOGE(TAG, "‚ùå Erreur r√©ception ou r√©ponse vide !");
        lv_label_set_text_fmt(ui_Label1, "Err");
        lv_obj_invalidate(ui_Label1);
        lv_label_set_text_fmt(ui_Label22, "Err HTTP");
        lv_obj_invalidate(ui_Label22);
    }

    free(recv_buf);
    close(sock);
    xSemaphoreGive(http_mutex);
}

void parse_json_data(const char *json) {
    if (json == NULL || strlen(json) == 0) {
        ESP_LOGE(TAG, "‚ùå Donn√©es JSON vides ou invalides !");
        lv_label_set_text_fmt(ui_Label1, "Err");
        lv_obj_invalidate(ui_Label1);
        lv_label_set_text_fmt(ui_Label22, "JSON vide");
        lv_obj_invalidate(ui_Label22);
        return;
    }

    cJSON *root = cJSON_Parse(json);
    //ESP_LOGI("HTTP_CLIENT", "Contenu re√ßu : %s", json);
    if (!root) {
        ESP_LOGE(TAG, "‚ùå Erreur de parsing JSON !");
        lv_label_set_text_fmt(ui_Label1, "Err");
        lv_obj_invalidate(ui_Label1);
        lv_label_set_text_fmt(ui_Label22, "Err JSON");
        lv_obj_invalidate(ui_Label22);
        return;
    }
    char extracted_temperature[128] = "N/A";
    char extracted_pression[128] = "N/A";

    ///////////// CAPTEUR EXTERNE ///////////////////
    cJSON *common_list = cJSON_GetObjectItem(root, "common_list");
    if (cJSON_IsArray(common_list)) {
        int array_size = cJSON_GetArraySize(common_list);
        for (int i = 0; i < array_size; i++) {
            cJSON *item = cJSON_GetArrayItem(common_list, i);
            if (!cJSON_IsObject(item)) continue;

            cJSON *id = cJSON_GetObjectItem(item, "id");
            cJSON *val = cJSON_GetObjectItem(item, "val");

            if (!cJSON_IsString(id) || !cJSON_IsString(val)) continue;

            if (strcmp(id->valuestring, "0x02") == 0) {
                snprintf(extracted_temperature, sizeof(extracted_temperature), "%s", val->valuestring);
            }
            else if (strcmp(id->valuestring, "0x0B") == 0) {
                vent_vitesse = strtof(val->valuestring, NULL);
            }
            else if (strcmp(id->valuestring, "0x0C") == 0) {
                vent_rafale = strtof(val->valuestring, NULL);
            }
            else if (strcmp(id->valuestring, "0x19") == 0) {
                vent_rafale_jour = strtof(val->valuestring, NULL);
            }
            else if (strcmp(id->valuestring, "0x0A") == 0) {
                vent_direction = strtof(val->valuestring, NULL);
            }
            
            if (cJSON_IsString(id) && strcmp(id->valuestring, "0x0A") == 0) {
                cJSON *battery = cJSON_GetObjectItem(item, "battery");
                cJSON *voltage = cJSON_GetObjectItem(item, "voltage");
    
                if (cJSON_IsString(battery) && cJSON_IsString(voltage)) {
                    //ESP_LOGI("PILE", "üîã Batterie : %s / Tension : %s V", battery->valuestring, voltage->valuestring);
                    char battery_str[128];  // Buffer pour la cha√Æne √† afficher
                    strcpy(battery_str, battery->valuestring);
                    snprintf(battery_str, sizeof(battery_str), "üîã Batterie : %s/5", battery->valuestring);
                    lv_label_set_text_fmt(ui_Label16, battery_str);
                    lv_obj_invalidate(ui_Label16);
                    
                    int battery_level = 0;

                    if (cJSON_IsString(battery) && battery->valuestring != NULL) {
                        battery_level = atoi(battery->valuestring);}
                    if (battery_level_old != battery_level) {
                        ESP_LOGI("BATTERY", "%d/5", battery_level);}
                    battery_level_old = battery_level;
                    if (compteur_pression == 0 && battery_level >= 1 && battery_level <= 5) {
                        //ESP_LOGI("BATTERY", "üîã Batterie : %d/5", battery_level);
                        int bips = 6 - battery_level;
                        for (int i = 0; i < bips; i++) {
                            //Set_EXIO(TCA9554_EXIO8, true);   //bip de d√©marrage
                            vTaskDelay(pdMS_TO_TICKS(1000));
                            Set_EXIO(TCA9554_EXIO8, false);
                            if (i < bips - 1) {
                                vTaskDelay(pdMS_TO_TICKS(500));
                            }
                        }
                        // Alerte sp√©ciale si batterie faible
                        if (battery_level <= 2) {
                            vTaskDelay(pdMS_TO_TICKS(1500));  // Petite pause avant l'alerte
                            for (int j = 0; j < 3; j++) {
                                Set_EXIO(TCA9554_EXIO8, true);
                                vTaskDelay(pdMS_TO_TICKS(300));
                                Set_EXIO(TCA9554_EXIO8, false);
                                vTaskDelay(pdMS_TO_TICKS(200));
                            }
                            ESP_LOGW("BATTERY", "‚ö†Ô∏è Batterie faible !");
                        }
                    }
                }
            }
        }
    } else {
        ESP_LOGW(TAG, "‚ö†Ô∏è Aucune donn√©e `common_list` trouv√©e !");
        lv_label_set_text_fmt(ui_Label1, "N/A");
        lv_obj_invalidate(ui_Label1);
        lv_label_set_text_fmt(ui_Label25, "Min: N/A");
        lv_obj_invalidate(ui_Label25);
        lv_label_set_text_fmt(ui_Label26, "Max: N/A");
        lv_obj_invalidate(ui_Label26);
        lv_label_set_text_fmt(ui_Label16, "N/A");
        lv_obj_invalidate(ui_Label16);
    }

    ///////////// CAPTEUR INTERNE /////////////////////////
    cJSON *wh25 = cJSON_GetObjectItem(root, "wh25");
    if (cJSON_IsArray(wh25) && cJSON_GetArraySize(wh25) > 0) {
        cJSON *first_sensor = cJSON_GetArrayItem(wh25, 0);
        cJSON *humidity = cJSON_GetObjectItem(first_sensor, "inhumi");
        cJSON *pression = cJSON_GetObjectItem(first_sensor, "abs");

        if (cJSON_IsString(humidity)) {
            //ESP_LOGI(TAG, "üíß Humidit√© int√©rieure : %s", humidity->valuestring);
        }
        if (cJSON_IsString(pression)) {
            snprintf(extracted_pression, sizeof(extracted_pression), "%s", pression->valuestring);
        }

        compteur_pression++;
        snprintf(temperature_str, sizeof(temperature_str), "%s", extracted_temperature);
        snprintf(pression_str, sizeof(pression_str), "%s", extracted_pression);

        temperature_actuelle = atof(temperature_str);
        // Mise √† jour temp√©rature min/max

        if (temperature_actuelle > temperature_max) {
            temperature_max = temperature_actuelle;
            save_data_to_sdcard(temperature_max, temperature_min);
        }

        if (temperature_actuelle < temperature_min) {
            temperature_min = temperature_actuelle;
            save_data_to_sdcard(temperature_max, temperature_min);
        }

        if (compteur_pression != 1) {

            snprintf(temperature_max_str, sizeof(temperature_max_str), "Max: %.1F¬∞C", temperature_max);
            snprintf(temperature_min_str, sizeof(temperature_min_str), "Min: %.1F¬∞C", temperature_min);
            lv_label_set_text_fmt(ui_Label25, temperature_min_str);
            lv_obj_invalidate(ui_Label25);
            lv_label_set_text_fmt(ui_Label26, temperature_max_str);
            lv_obj_invalidate(ui_Label26);
            update_temperature_display();
        }
        pression_actuelle = atof(pression_str);
        
        //////// GRAPHE ////////////
        static int compteur_minutes = 0;
        compteur_minutes++;

        if (compteur_minutes >= 235 || compteur_minutes == 1) {  // avec 78 points sur 24h
            //ESP_LOGI("BARO", "üìä Pression mesur√©e: %.2f hPa", pression_actuelle);
            //ESP_LOGI("BARO", "‚è±Ô∏è Temps=%d", compteur_minutes);
            compteur_minutes = 1;
            baro_add_value(pression_actuelle);
        }
        ////////////////////////////

    } else {
        ESP_LOGW(TAG, "‚ö†Ô∏è Aucune donn√©e `wh25` trouv√©e !");
        lv_label_set_text_fmt(ui_Label22, "N/A");
        lv_obj_invalidate(ui_Label22);
    }

    cJSON_Delete(root);
}

void update_temperature_display() {
    lv_label_set_text_fmt(ui_Label1, temperature_str);
    lv_obj_invalidate(ui_Label1);
    lv_label_set_text_fmt(ui_Label22, pression_str);
    lv_obj_invalidate(ui_Label22);
}

void temperature_task(void *pvParameters) {
    const char *host = "192.168.2.237";
    const char *path = "/get_livedata_info?";
    uint16_t port = 80;

    while (1) {
        //ESP_LOGI(TAG, "Rafra√Æchissement des donn√©es m√©t√©o...");
        http_simple_get(host, path, port);
        //ESP_LOGI(TAG, "Rafra√Æchissement termin√©.");
        vTaskDelay(pdMS_TO_TICKS(2300));  // Toutes les 2,3 sec
    }
}

void init_http_client() {
    http_mutex = xSemaphoreCreateMutex();
    //if (http_mutex == NULL) {
        //ESP_LOGE(TAG, "‚ùå Impossible de cr√©er le mutex HTTP !");
    //} else {
        //ESP_LOGI(TAG, "Mutex HTTP initialis√© avec succ√®s.");
    //}
}

    /////////// SAUVEGARDE ///////////////////
void save_data_to_sdcard(float temperature_max, float temperature_min) {
    FILE* f = fopen("/sdcard/data.csv", "a");  // Mode append (ajout)
    if (f == NULL) {
        ESP_LOGE(TAG, "Erreur ouverture fichier !");
        return;
    }
    if (temperature_min != 100.0f && temperature_max != -100.0f){
        fprintf(f, "%.2f,%.2f\n", temperature_max, temperature_min);
        fclose(f);
        ESP_LOGI(TAG, "‚úÖ Donn√©es √©crites : %.2f¬∞C, %.1f ¬∞C", temperature_max, temperature_min);
    }
    
}

void lire_donnees_sdcard(void) {
    FILE* f = fopen("/sdcard/data.csv", "r"); // Mode lecture (read)
    if (f == NULL) {
        ESP_LOGE(TAG, "‚ùå Impossible d'ouvrir le fichier !");
        return;
    }

    char ligne_buffer[128];
    int numero_ligne = 0;
    ESP_LOGI(TAG, "üîç Lecture du fichier...");
    while (fgets(ligne_buffer, sizeof(ligne_buffer), f) != NULL) {
        // Supprimer le retour √† la ligne
        ligne_buffer[strcspn(ligne_buffer, "\r\n")] = 0;
        // Lecture des valeurs (format CSV)
        if (sscanf(ligne_buffer, "%f,%f", &temperature_max, &temperature_min) == 2) {
            //ESP_LOGI(TAG, "Ligne %d ‚Üí temperature_max: %.1f¬∞C, temperature_min: %.1f ¬∞C",
            //         ++numero_ligne, temperature_max, temperature_min);
        } else {
            ESP_LOGW(TAG, "‚ö†Ô∏è Ligne %d invalide", ++numero_ligne);
            temperature_max = -100.0f;
            temperature_min = 100.0f;
        }
    }
    ESP_LOGI(TAG, "Lecture du fichier termin√©.");
    fclose(f);
}
